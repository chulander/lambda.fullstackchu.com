'use strict';

const jwt = require('jsonwebtoken');
const querystring = require('querystring');

/**
 * This function demonstrates how you can read the body of a POST request
 * generated by an HTML form (web form). The function is triggered in a
 * CloudFront viewer request or origin request event type.
 */

exports.handler = (event, context, callback) => {
  const secret = 'euc lifecycle 2018';
  const users = [
    {
      id: 1,
      username: 'batman',
      password: 'batman'
    },
    {
      id: 2,
      username: 'joker',
      password: 'joker'
    },
    {
      id: 3,
      username: 'bryan',
      password: 'bryan'
    }
  ];
  const request = event.Records[0].cf.request;

  const { headers } = request;
  console.log('what is request.method', request.method);
  console.log('what is request.uri', request.uri);
  const {
    host: [{ value: hostEndpoint }],
    referer = []
  } = headers;
  const redirectEndpoint =
    referer[0] && referer[0].value !== hostEndpoint ? referer[0].value : `${hostEndpoint}/success`;

  if (request.method === 'GET') {
    if (!headers.authorization) {
      console.log('no authorization headers: forwarding viewer request');
      return callback(null, request);
    } else {
      console.log('auth headers found', headers.authorization);
      const [type, token] = headers.authorization.split(' ');
      jwt.verify(token, secret, (err, val) => {
        if (err) {
          console.log('jwt verify error: fowarding request', err);
          return callback(null, request);
        } else {
          console.log('jwt verify success: forwarding to referer or success', referer, val);
          return callback(null, {
            status: '200',
            statusDescription: 'Authenticated',
            headers: {
              key: 'Location',
              value: redirectEndpoint
            }
          });
        }
      });
    }
  } else if (request.method === 'POST') {
    console.log('event is', JSON.stringify(event));
    console.log('request.headers is', JSON.stringify(headers));
    /* HTTP body is always passed as base64-encoded string. Decode it. */

    const body = Buffer.from(request.body.data, 'base64').toString();
    console.log('request body is', JSON.stringify(body));

    const { username, password } = JSON.parse(body);
    const foundUser = users.filter(
      user => user.username === username && user.password === password
    )[0];
    if (!foundUser) {
      console.log('jwt invalid: returning 401');
      callback(null, {
        status: '401',
        statusDescription: 'Unauthorized'
      });
    } else {
      // const response = {
      //     status: '302',
      //     statusDescription: 'Found',
      //     headers: {
      //       location: [{
      //         key: 'Location',
      //         value: 'https://bit.ly/very-secret'
      //       }],
      //     },
      //   };
      console.log('passing jwt verify');
      //If all credentials are correct do this
      let token = jwt.sign({ id: foundUser.id, username: foundUser.username }, secret, {
        expiresIn: 129600
      }); // Sigining the token

      const { referer } = headers;
      console.log('user auth post success: forwarding to referer or success', referer);
      callback(null, {
        status: '200',
        statusDescription: 'Authenticated',
        headers: {
          key: 'Location',
          value: redirectEndpoint
        }
      });
    }

    /* HTML forms send the data in query string format. Parse it. */
    // const params = querystring.parse(body);

    /* For demonstration purposes, we only log the form fields here.
     * You can put your custom logic here. For example, you can store the
     * fields in a database, such as AWS DynamoDB, and generate a response
     * right from your Lambda@Edge function.
     */
    // for (let param in params) {
    //   console.log(`For "${param}" user submitted "${params[param]}".\n`);
    // }
  } else {
    console.log('unhandled request method', request.method);
    return callback(null, request);
  }
};
